Volatile是Java中的一个关键字，在并发编程中扮演重要角色，如果使用恰当的话性能会比Synchronized效率更高。因为volatile不会引起线程上下文的切换和调度。

两大作用：

* 使得内存对全部线程可见
* 防止指令重排序



使用volatile关键字修饰的变量，在修改以后会对所有线程可见（修改后的值）。这个功能在底层是通过一条以lock为前缀的汇编语句来实现的。以lock为前缀的汇编语句在多核处理器中做了两件事情：

第一事情把当前cpu缓存中的数据写回到主存里（关于缓存和主存可以参考计组的知识），这步会使当前cpu独占主存，以防止其它线程同步写入时出现数据丢失。所以当前cpu会锁住主存的总线，锁住总线就意味着其它cpu不能访问主存。

第二件事情是使得其它cpu缓存中对应变量的缓存失效。光更新主存是不够的，还必须另其它cpu缓存里的旧数据失效。所以在多处理器下，各个处理器会实现缓存一致性协议，各个cpu通过嗅探总线上传递过来的数据来知道自己是否有数据失效了。（这步和计网中广播的方式类似）



防止指令重排序，cpu指令的执行顺序是不确定的（计组），volatile通过增加内存屏障防止cpu指令重排，以防止在并发条件下出问题。cpu重排指令是保证在单线程情况下运行结果不会变。

关于指令重排，一个经典案例是DCL单例（double check lock）。因为new一个object并不是原子操作，包括三个步骤，1.申请内存，此时成员变量都是0值，2.调用构造函数 3.把栈变量和堆内存建立联系。 可以考虑，如果单例模式里的成员变量不用volatile关键字修饰，当一个线程在new对象时，可能发生指令重排（1->3->2）这个重排并不会影响该线程中的返回值结果，但是如果此时另一个线程运行时判定单例对象不为空于是拿到了一个对象，但是此时还并没有执行构造函数，于是，错误就产生了。
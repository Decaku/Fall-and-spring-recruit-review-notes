[toc]

Redis的数据都是保存在内存里，当机器出现宕机或重启等问题时，内存里的数据就会发生丢失。因此必须把内存里的数据写入到硬盘里，以便内存数据丢失后能通过硬盘恢复，这个过程称为持久化。

# RDB

RDB是一种快照存储的持久化方式，它在某一时刻把数据全都写到硬盘里，生成默认名为dump.rdb的文件。简单来说，就是把数据拷贝了一份存储在磁盘里。

优点：

* RDB实现是主进程fork出一个子进程，然后让子进程做持久化工作，所以它对redis对外提供服务时影响非常小。
* 恢复数据时比较快，适合做冷备份。

缺点：

* 这种方式最大的问题是两次RDB备份之间的时间gap比较大，因此在这个gap中服务器发生宕机那么丢失的数据会比较多。
* fork的子进程在进行RDB备份时如果文件比较大可能会导致主进程延迟。（一般不会）

为什么Redis是fork一个子进程来做RDB，而不是new一个线程？

因为快照保存的是某一时刻redis里的数据，举个例子，在6:15执行RDB，使用fork进程那就会把这个时刻的数据拷贝到子进程里(其实会COW机制优化)，但是多线程的话共享的是一份数据，那么主线程修改了数据，备份的就不知道是哪个时刻的数据了。

这会有影响吗？单机的redis没啥问题，数据越新越好，我不需要具体知道它是哪个时刻的。但是如果是redis集群做主从备份就有问题了，因为redis主从备份是让从结点复制某一时刻主节点的RDB备份，然后重新执行这个RDB之后的所有命令，达到和主节点相同的状态。如果这个RDB不是严格某一时刻的，那么就有可能让后面的命令重复执行了，数据不一致。



# AOF

AOF（append-only file）是一种文件追加写的备份方式。简单来说就是每当redis执行一条write命令时，就把这条命令写入磁盘上的一个文件中，恢复数据时只需从头执行这个文件里的所有指令即可。

优点：

* 数据完整性更好，不会丢失许多数据，一般来说redis通过后台一个fsync线程去写文件，所以宕机最多丢失一秒的数据。
* 以append-only的方式写入命令，所以即使是磁盘IO也会很快，因为减少了磁头寻址的过程。（这点和kafka的消息文件一样）

缺点：

* 最大的问题是随着服务运行，AOF文件最后可能会非常大。
* 由于文件过大，恢复数据时可能也就比较慢了。
* QPS会受到影响，因为每秒都会执行系统调用fsync。

# 实际使用

redis默认以RDB的方式做持久化，实际使用可以以AOF来保证数据完整性，以RDB来对数据做不同程度冷备份。遇到紧急情况使用RDB快速恢复。
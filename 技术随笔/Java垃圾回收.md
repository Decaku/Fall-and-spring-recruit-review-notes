这将是一篇长文:),提前挖好坑。

[toc]

# 简述

深入理解Java虚拟机中有这样一句话，“Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来”。实际上，不只是Java，python，golang这些编程语言也有垃圾自动回收机制。自动回收垃圾使程序减少了内存泄漏的风险。本文仅讨论Java的垃圾回收，其它支持GC（Garbage Collection）的语言内部实现大同小异。

# 对象是否死亡

垃圾回收器管理的内存主要是堆上的内存，当一个对象“死亡”时，它占有的内存就该被回收了。而判断对象存活的算法有引用计数法和根可达性分析算法。

## 引用计数法

这种算法的思路是在对象内部添加一个引用计数器，每当一个地方引用这个对象时，就让引用计数器加1，当引用失效时，就让引用计数器减1。如果一个对象的引用次数为0，就可以判断它已经死亡。

实际上，python就是使用了引用计数法进行垃圾判断。但是这种算法会出现循环引用计数的问题，两个对象互相引用且没有任何其它地方再对它们引用，此时这两个对象本来也应该被判断已经死亡。这个问题解决思路可以参考C++ 11中的智能指针(shared_ptr和weak_ptr)，当两个对象互相引用时，一个对象引用计数器加1，让另一个不变。但是这种方法很复杂，C++也还是把这个问题交给了程序员，你需要知道哪些地方会出现这种问题，然后自己注意智能指针的合理使用。

## 根可达性分析

Java中使用的是这种算法来判断对象是否死亡。有一系列称为"GC Roots"的对象作为起点集，根据引用关系向下搜索(引用链)，能够搜索到的对象就是存活的。用图论里的术语来说就是存活的对象必定和某一个root在同一个连通集里。

能作为“GC Roots”的对象有以下几种。Java虚拟机栈中引用的对象；方法区中类的静态属性引用的对象；方法区中常量引用的对象；本地方法栈中引用的对象；被同步锁(synchronized关键字)持有的对象。另外还有些不常用的，比如基本数据类型对应的Class对象，常驻的异常类对象，系统类加载器以及本地代码缓存等。

除了这些固定对象，可能还会有些临时性加入的对象，比如对新生代进行GC时,如果有其它区域的对象引用了新生代里的对象，则要把引用者加入到“GC Roots”里。

## finalize方法

finalize方法是Object类的方法。如果一个对象在面临GC且被标记为垃圾时，在回收前它有一次自救的机会，执行finalize方法，如果它又被活着的对象引用了，那它就可以避免这次回收。但是这个方法比较鸡肋，因为所有要执行finalize的对象都会被丢到一个队列，由一个低调度优先级的线程执行。JVM只能保证方法会被执行，但不能保证何时执行或在对象被回收前是否执行。这样的话在finalize执行前或执行完之前对象可能就被回收了。。。并且每个对象的finalize方法只会被执行一次，到了下次GC时就不会执行finalize。

# 回收目标空间

一般来说，垃圾回收器回收的主要目标是堆空间。但并不意味着其它空间不会发生GC。

## 方法区回收

方法区里存的主要是类的信息和常量。Java虚拟机规范里并未要求对这部分空间进行GC，JDK 11时期的ZGC回收器就不支持类卸载。因为类卸载的条件比较苛刻，对这部分GC收益不大。

对于常量还好，只要不再被引用就可以回收。但是类卸载要满足三个条件，该类及子类的所有实例对象被回收；该类对应的类加载器被回收；该类对应的java.lang.class对象被回收。

如果是在大量使用反射，动态代理等场景下，需要JVM具备类卸载的能力，以防对方法区造成过大的内存压力。






这将是一篇长文:),提前挖好坑。

[toc]

# 简述

深入理解Java虚拟机中有这样一句话，“Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来”。实际上，不只是Java，python，golang这些编程语言也有垃圾自动回收机制。自动回收垃圾使程序减少了内存泄漏的风险。本文仅讨论Java的垃圾回收，其它支持GC（Garbage Collection）的语言内部实现大同小异。

# 对象是否死亡

垃圾回收器管理的内存主要是堆上的内存，当一个对象“死亡”时，它占有的内存就该被回收了。而判断对象存活的算法有引用计数法和根可达性分析算法。

## 引用计数法

这种算法的思路是在对象内部添加一个引用计数器，每当一个地方引用这个对象时，就让引用计数器加1，当引用失效时，就让引用计数器减1。如果一个对象的引用次数为0，就可以判断它已经死亡。

实际上，python就是使用了引用计数法进行垃圾判断。但是这种算法会出现循环引用计数的问题，两个对象互相引用且没有任何其它地方再对它们引用，此时这两个对象本来也应该被判断已经死亡。这个问题解决思路可以参考C++ 11中的智能指针(shared_ptr和weak_ptr)，当两个对象互相引用时，一个对象引用计数器加1，让另一个不变。但是这种方法很复杂，C++把这个问题交给了程序员，你需要知道哪些地方会出现这种问题，然后自己手动维护好weak_ptr。

## 根可达性分析

Java中使用的是这种算法来判断对象是否死亡。有一系列称为"GC Roots"的对象作为起点集，根据引用关系向下搜索(引用链)，能够搜索到的对象就是存活的。用图论里的术语来说就是存活的对象必定和某一个root在同一个连通集里。

能作为“GC Roots”的对象有以下几种。Java虚拟机栈中引用的对象；方法区中类的静态属性引用的对象；方法区中常量引用的对象；本地方法栈中引用的对象；被同步锁(synchronized关键字)持有的对象。另外还有些不常用的，比如基本数据类型对应的Class对象，常驻的异常类对象，系统类加载器以及本地代码缓存等。

除了这些固定对象，可能还会有些临时性加入的对象，比如对新生代进行GC时,如果有其它区域的对象引用了新生代里的对象，则要把引用者加入到“GC Roots”里。

## finalize

finalize方法是Object类的方法。如果一个对象在面临GC且被标记为垃圾时，在回收前它有一次自救的机会，执行finalize方法，如果它又被活着的对象引用了，那它就可以避免这次回收。但是这个方法比较鸡肋，因为所有要执行finalize的对象都会被丢到一个队列，由一个低调度优先级的线程执行。JVM只能保证方法会被执行，但不能保证何时执行或在对象被回收前是否执行。这样的话在finalize执行前或执行完之前对象可能就被回收了。。。并且每个对象的finalize方法只会被执行一次，到了下次GC时就不会执行finalize。

# 回收目标空间

一般来说，垃圾回收器回收的主要目标是堆空间。但并不意味着其它空间不会发生GC。

## 方法区回收

方法区里存的主要是类的信息和常量。Java虚拟机规范里并未要求对这部分空间进行GC，JDK 11时期的ZGC回收器就不支持类卸载。因为类卸载的条件比较苛刻，对这部分GC收益不大。

对于常量还好，只要不再被引用就可以回收。但是类卸载要满足三个条件，该类及子类的所有实例对象被回收；该类对应的类加载器被回收；该类对应的java.lang.class对象被回收。

如果是在大量使用反射，动态代理等场景下，需要JVM具备类卸载的能力，以防对方法区造成过大的内存压力。

# GC算法

## 标记-清除

该算法是最基础的垃圾回收算法，分为标记和清楚两个阶段，标记阶段标记出所有已经死亡的对象，然后统一对死亡的对象进行回收。这个算法会带来两个问题，首先是效率，因为需要对大量对象标记然后回收。另外GC后可能会产生内存碎片，内存碎片难以被再次利用，这样当堆空间不够时只能提前触发下一次GC。

## 标记-复制

标记-复制算法解决了效率不高的问题。它的思路是把整个堆空间分成两半，每次只用其中一半的空间。当发生GC时，就把所有存活的对象复制到另一半空间（这里会连续存放，防止内存碎片），然后清空使用的一半空间。但是这样做对空间的利用率不高，因为每次只能有一半的堆空间被使用，另一半是空闲的。

## 标记-整理

标记-整理算法先标记出所有存活的对象，然后把它们整理到一段连续的内存中，并清除掉边界以外的空间。这种算法解决了内存碎片的问题，但是同样效率不高。

## 分代回收

实际上，现代虚拟机里的GC算法大多基于分代回收思想，分代回收对堆划分出不同的空间，在不同的空间使用不同的GC算法。

以HotSpot虚拟机举例。实际上，一次GC包括很多细节。

#### 寻找GC Roots

如果对栈帧(局部变量表)和方法区中的所有变量进行枚举，这样的时间花销是巨大的。HotSpot采用了准确式GC以提高效率，所谓准确式GC，就是在类加载时，JVM就能准确计算出对应偏移的内存里存放的是哪种数据类型。然后JVM用一种叫做OopMap（Ordinary Object Pointer Map）的数据结构来保存。但是，一份代码里可能会有许多指令会修改引用关系，如果每次有一条指令修改了引用关系，就去更新OopMap，这样的代价也太大了。于是，JVM只会在SafePoint对OopMap统一更新，这样保证了在安全点，引用关系一定是正确的，所以只有在安全点，程序才会触发GC行为。

#### 安全点

安全点如果过少，会导致GC间隔太长，太少又会增大运行负载。选择安全点的原则是“是否有让程序长时间执行的特征”，如方法调用，循环跳转等，这些过程最明显的特征就是有指令序列的复用。

#### 抢先式中断和主动式中断

在GC发生时，需要保证所有的线程都跑到安全点，这里有两种方式。

抢先式中断会把所有用户线程停止，如果有哪条线程不在安全点，就恢复线程跑一会让它跑到最近的安全点。（现在虚拟机一般不采用）

主动式中断会在安全点设置一个中断标记位，线程的内部不断轮询，跑到安全点时判断中断标记是否为真，如果为真就停下，为假就可以继续运行。（创建对象和在堆上分配内存的指令处也要设置标记，为了防止内存不够）因为轮询的次数会很多，所以对于轮询必须做简化，实际上这个操作只会调用一条汇编指令。

#### 安全区域

对于正在运行的线程，发生GC时可以跑到安全点停在。但如果是处在休眠或阻塞中的线程，JVM不可能等这些线程获得cpu然后运行到安全点再进行GC。

安全区域是一段引用关系不会发生变化的的代码片段，因此，在任何地方发生GC都是安全的。其实，处在休眠或者阻塞中的线程本身就是在安全区域里的，因为它不在执行，自然也不可能修改任何引用关系。在线程进入安全区域时，会进行标记，GC线程无需关注这些处在安全区域里的线程。当线程要离开安全区域时，首先会检查是否正在GC，如果正在GC就要等到GC结束后才可以离开。(我怎么感觉安全区域的定义和安全点完全不一样。。。)










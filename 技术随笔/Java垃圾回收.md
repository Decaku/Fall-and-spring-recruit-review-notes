这将是一篇长文:),提前挖好坑。

github的markdown目录有问题,下载再看体验会好一些。

[toc]

# 简述

深入理解Java虚拟机中有这样一句话，“Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来”。实际上，不只是Java，python，golang这些编程语言也有垃圾自动回收机制。自动回收垃圾使程序减少了内存泄漏的风险。本文仅讨论Java的垃圾回收，其它支持GC（Garbage Collection）的语言内部实现大同小异。

# 对象是否死亡

垃圾回收器管理的内存主要是堆上的内存，当一个对象“死亡”时，它占有的内存就该被回收了。而判断对象存活的算法有引用计数法和根可达性分析算法。

## 引用计数法

这种算法的思路是在对象内部添加一个引用计数器，每当一个地方引用这个对象时，就让引用计数器加1，当引用失效时，就让引用计数器减1。如果一个对象的引用次数为0，就可以判断它已经死亡。

实际上，python就是使用了引用计数法进行垃圾判断。但是这种算法会出现循环引用计数的问题，两个对象互相引用且没有任何其它地方再对它们引用，此时这两个对象本来也应该被判断已经死亡。这个问题解决思路可以参考C++ 11中的智能指针(shared_ptr和weak_ptr)，当两个对象互相引用时，一个对象引用计数器加1，让另一个不变。但是这种方法很复杂，C++把这个问题交给了程序员，你需要知道哪些地方会出现这种问题，然后自己手动维护好weak_ptr。

## 根可达性分析

Java中使用的是这种算法来判断对象是否死亡。有一系列称为"GC Roots"的对象作为起点集，根据引用关系向下搜索(引用链)，能够搜索到的对象就是存活的。用图论里的术语来说就是存活的对象必定和某一个root在同一个连通集里。

能作为“GC Roots”的对象有以下几种。Java虚拟机栈中引用的对象；方法区中类的静态属性引用的对象；方法区中常量引用的对象；本地方法栈中引用的对象；被同步锁(synchronized关键字)持有的对象。另外还有些不常用的，比如基本数据类型对应的Class对象，常驻的异常类对象，系统类加载器以及本地代码缓存等。

除了这些固定对象，可能还会有些临时性加入的对象，比如对新生代进行GC时,如果有其它区域的对象引用了新生代里的对象，则要把引用者加入到“GC Roots”里。

## finalize

finalize方法是Object类的方法。如果一个对象在面临GC且被标记为垃圾时，在回收前它有一次自救的机会，执行finalize方法，如果它又被活着的对象引用了，那它就可以避免这次回收。但是这个方法比较鸡肋，因为所有要执行finalize的对象都会被丢到一个队列，由一个低调度优先级的线程执行。JVM只能保证方法会被执行，但不能保证何时执行或在对象被回收前是否执行。这样的话在finalize执行前或执行完之前对象可能就被回收了。。。并且每个对象的finalize方法只会被执行一次，到了下次GC时就不会执行finalize。

# 回收目标空间

一般来说，垃圾回收器回收的主要目标是堆空间。但并不意味着其它空间不会发生GC。

## 方法区回收

方法区里存的主要是类的信息和常量。Java虚拟机规范里并未要求对这部分空间进行GC，JDK 11时期的ZGC回收器就不支持类卸载。因为类卸载的条件比较苛刻，对这部分GC收益不大。

对于常量还好，只要不再被引用就可以回收。但是类卸载要满足三个条件，该类及子类的所有实例对象被回收；该类对应的类加载器被回收；该类对应的java.lang.class对象被回收。

如果是在大量使用反射，动态代理等场景下，需要JVM具备类卸载的能力，以防对方法区造成过大的内存压力。

# GC算法

## 标记-清除

该算法是最基础的垃圾回收算法，分为标记和清楚两个阶段，标记阶段标记出所有已经死亡的对象，然后统一对死亡的对象进行回收。这个算法会带来两个问题，首先是效率，因为需要对大量对象标记然后回收。另外GC后可能会产生内存碎片，内存碎片难以被再次利用，这样当堆空间不够时只能提前触发下一次GC。

## 标记-复制

标记-复制算法解决了效率不高的问题。它的思路是把整个堆空间分成两半，每次只用其中一半的空间。当发生GC时，就把所有存活的对象复制到另一半空间（这里会连续存放，防止内存碎片），然后清空使用的一半空间。但是这样做对空间的利用率不高，因为每次只能有一半的堆空间被使用，另一半是空闲的。

## 标记-整理

标记-整理算法先标记出所有存活的对象，然后把它们整理到一段连续的内存中，并清除掉边界以外的空间。这种算法解决了内存碎片的问题，但是同样效率不高。

## 分代回收

实际上，现代虚拟机里的GC算法大多基于分代回收思想，分代回收对堆划分出不同的空间，在不同的空间使用不同的GC算法。

以HotSpot虚拟机举例。实际上，一次GC包括很多细节。

### 寻找GC Roots

如果对栈帧(局部变量表)和方法区中的所有变量进行枚举，这样的时间花销是巨大的。HotSpot采用了准确式GC以提高效率，所谓准确式GC，就是在类加载时，JVM就能准确计算出对应偏移的内存里存放的是哪种数据类型。然后JVM用一种叫做OopMap（Ordinary Object Pointer Map）的数据结构来保存。但是，一份代码里可能会有许多指令会修改引用关系，如果每次有一条指令修改了引用关系，就去更新OopMap，这样的代价也太大了。于是，JVM只会在SafePoint对OopMap统一更新，这样保证了在安全点，引用关系一定是正确的，所以只有在安全点，程序才会触发GC行为。

### 安全点

安全点如果过少，会导致GC间隔太长，太少又会增大运行负载。选择安全点的原则是“是否有让程序长时间执行的特征”，如方法调用，循环跳转等，这些过程最明显的特征就是有指令序列的复用。

### 抢先式中断和主动式中断

在GC发生时，需要保证所有的线程都跑到安全点，这里有两种方式。

抢先式中断会把所有用户线程停止，如果有哪条线程不在安全点，就恢复线程跑一会让它跑到最近的安全点。（现在虚拟机一般不采用）

主动式中断会在安全点设置一个中断标记位，线程的内部不断轮询，跑到安全点时判断中断标记是否为真，如果为真就停下，为假就可以继续运行。（创建对象和在堆上分配内存的指令处也要设置标记，为了防止内存不够）因为轮询的次数会很多，所以对于轮询必须做简化，实际上这个操作只会调用一条汇编指令。

### 安全区域

对于正在运行的线程，发生GC时可以跑到安全点停在。但如果是处在休眠或阻塞中的线程，JVM不可能等这些线程获得cpu然后运行到安全点再进行GC。

安全区域是一段引用关系不会发生变化的的代码片段，因此，在任何地方发生GC都是安全的。其实，处在休眠或者阻塞中的线程本身就是在安全区域里的，因为它不在执行，自然也不可能修改任何引用关系。在线程进入安全区域时，会进行标记，GC线程无需关注这些处在安全区域里的线程。当线程要离开安全区域时，首先会检查是否正在GC，如果正在GC就要等到GC结束后才可以离开。(我怎么感觉安全区域的定义和安全点完全不一样。。。)



### 并发可达性分析

在GC时，在寻找GC Roots这个阶段一定会触发STW(stop the world)，所有的用户线程必须停下。但是在从GC Roots开始搜索引用对象时，这个阶段是可以和用户线程并发执行的。而用户线程很有可能会修改引用关系，那么在这个场景下，GC线程必须要采取一些策略。如果在并发阶段，GC收集器把原本已经死亡的对象标记为存活，这种情况是可以容忍的，无非是产生了一些浮动垃圾，等待下次GC就可以。但是如果用户线程把原本死亡的对象添加到存活对象的引用链上，而GC线程又没有修改状态时，就会产生严重的后果，这相当于存活对象被回收了。

为此，GC收集器使用了一种叫做三色标记法的算法。这种算法会把每个对象标记为三种状态之一。黑色：表示该对象是GC Root，或者与该对象相连的其它子对象都被扫描过。灰色,表示正在扫描该对象，但是与该对象相连的其它对象还没有扫描并且将来会扫描它的子结点。白色，表示该对象并未被扫描，如果扫描完成后一个对象还是白色，说明这个对象是垃圾，需要被回收。

一个场景，并发阶段用户线程把一个灰色结点添加为一个黑色结点的子结点。因为黑色结点是已经被完全扫描完成的结点，所以GC收集器不会再去扫描该结点的子结点，这样就会出现存活对象没有被标记出来的问题。

两种解决办法，增量更新（Incremental Update），当一个白色结点被一个黑色结点引用时，就把黑色结点标记成灰色，这样GC收集线程就会重新扫描该结点和它的子结点，CMS垃圾收集器目前使用该策略。

另一种办法，原始快照法（SATB），当一个引用关系删除时，会把它保存起来重新扫描漏掉的结点。举例就是如果一个灰色结点引用了一个白色结点，这时用户线程删除了引用关系，并让一个新的黑色结点重新引用了白色结点。SATB算法会把被删除的白色结点保存起来保证该结点还会被继续扫描到。G1垃圾收集器目前使用该策略。



### 堆区分代

堆区可以分为新生代和老年代，空间占比是1:3，而新生代又可以分为Eden区和两个Survivor区，空间占比是8:1:1，在为对象分配堆空间时，会占用Eden和S0的空间，当经历一次垃圾回收时，熬过第一次GC的对象就会被从Eden和S0区拷贝到S1区。新生代使用的垃圾回收算法是标记-复制算法，因为大部分的对象实际上都熬不过第一次GC（朝生夕死，据统计大概有98%），所以这种算法只需复制少量存活的对象，并且空间的利用率达到90%，因为只有一个S区被浪费了。但是也有可能在经历一次GC后，存活的对象大小超过了10%，此时一个S区是存不下的，这些对象就会被移动到老年代。新生代的S0和S1区彼此之间可以互相拷贝对象，再经历了多次GC后仍然存活的对象可以认为是不易回收的，这样的对象会被移动到老年代。

老年代使用的GC算法是标记-整理算法，因为老年代发生GC的频率很小。实际上，只针对老年代进行GC（old GC）只有CMS垃圾收集器会这么做。其它垃圾收集器当老年代空间不足时会触发全局的GC（full GC）。



# 垃圾收集器

## Serial

顾名思义，这是一个单线程的新生代垃圾收集器。不仅指它的回收线程只有一条，同时回收时用户线程必须完全停止（STW的时间很长）。这种垃圾收集器适用于单核处理机。它的优点是简单，占用的额外内存少。适用于client模式下的JVM（跑桌面程序和微服务）。

## ParNew

和Serial唯一的区别仅在于使用多线程垃圾收集（STW时间仍然很长），一般配合老年代的CMS垃圾收集器一起使用。

## Paraller Scavenge

一个多线程的新生代垃圾收集器。最大的特点是关注吞吐量（用户线程执行时间/(GC线程执行时间+用户线程执行时间)）而不是停顿时间。因此非常适合后台计算任务，而不适合与用户交互的服务或要求响应时间及时的服务。会和老年代的Paraller Old配合使用。

## Serial Old

老年代的Serial收集器。使用标记-整理算法。

## Paraller Old

老年代的Paraller Scavenge 收集器。

## CMS

全名叫Concurrent Mark Sweep，是一款老年代垃圾收集器，这款收集器的出现可以说有着承上启下的意义，因为在此之后各种优秀的GC收集器相继出现了。CMS追求以最短的停顿时间为目标，可以做到让用户线程和GC线程并发进行。

CMS的垃圾收集分为四个阶段。

* 初始化标记。标记出所有与GC Roots直接相连的对象，这部分时间很短。
* 并发标记。用户线程和GC线程同时执行。根据引用关系搜索和标记。
* 重新标记。修正因为用户线程和GC线程同时进行而造成的引用关系错误。
* 并发清除。用户线程和GC线程同时执行。回收死亡对象。

其中重新标记阶段使用的是增量更新算法，上文已经介绍过。

这款垃圾收集器在消耗时间最长的标记和清除阶段都做到了并行，因此停顿时间很短。但是它也存在着三大问题。

* 对CPU资源敏感（并发收集）。对于核心较少的机器不友好。
* 无法处理浮动垃圾，因为清除阶段是并发的，在这个阶段如果产生新的垃圾只能等到下次GC再回收了。并且因为浮动垃圾的存在，必须预留一部分空间，否则浮动垃圾占满内存后，就会出现Concurrent Mode Failure，这是JVM会临时启用Serial Old代替CMS。
* 因为采取了标记-清除算法，会产生内存碎片。CMS提供了一个参数-XX:+UseCMSCompactAtFullCollection，当存储不了大对象时，会开始整理内存碎片。

## G1

G1把堆空间分为若干个大小相等的Region，事实上，Eden,Survior和老年区都是一系列Region的集合。Region中有一个特殊的Humongous区域专门用来存储大对象，当一个对象大小超过一个Region的一半时即认为是大对象。当一个对象容量超过了一个Region大小时，就把它存放在一组连续的Humongous Region里。

G1的垃圾收集分为四个阶段，其中前三个阶段和CMS几乎一样。

* 初始化标记。标记出所有与GC Roots直接相连的对象。
* 并发标记。并发标记。用户线程和GC线程同时执行。根据引用关系搜索和标记。
* 并发标记。用户线程和GC线程同时执行。根据引用关系搜索和标记。
* 筛选回收。这个阶段会把所有的Region的回收成本和价值排序，然后根据用户的期望停顿时间来选择Region组成回收集，把要回收的Region里活着的对象移动到空的Region里，然后清空原来Region。这部分涉及到对象的移动，必须暂停用户线程。

与CMS收集器对比，G1有三大优势。

* 建立了可预测时间的回收模型，用户可以自己设定回收时间，然后GC收集器根据用户期待的回收时间对垃圾对象做选择性回收。
* 新生代老年代都能使用，因为它把空间分成了若干个Region，新生代和老年代都是一些Region的集合。
* CMS会产生内存碎片而G1不会，G1宏观上基于标记-整理(Region间拷贝也可以认为是标记-复制)算法。
















[toc]



# 类加载过程

在Java程序运行过程中，如果要使用的某个类不在内存里，则必须先把Class文件加载进内存。这个过程可以分为加载，连接和初始化，其中连接又分为验证，准备，解析三个过程。在类使用完以后还会被卸载。

## 加载

JVM通过类的全限定名获取该类的二进制字节流并把它加载到方法区，还会在内存里生成类对应的java.lang.class对象。其中获取二进制字节流可能是从编译好的class文件中获取，还有一些其他途径。比如从jar包获取，从网络上获取(Web Applet)以及运行时计算生成(动态代理)等等。这个阶段是程序员可以介入的，如通过自定义的类加载器实现加载，之后的阶段都会交付给JVM负责。

## 验证

验证是为了保护JVM的安全。因为二进制字节流的来源有很多，尽管java从语言层面限制了许多操作，如不允许数组越界访问，否则编译会抛出异常，但是许多java代码层面无法做到的事情可以通过直接编辑字节码实现，所以必须对字节码做校验来保护JVM。

* 文件格式校验，这个过程是校验class文件是否符合规范，比如魔数是否以0xCAFEBABE开头，版本号是否被JVM接受等等。
* 元数据校验，这个过程会对类的元数据信息进行语义校验，比如类是否继承了final修饰的类，子类是否和父类产生矛盾，非抽象类是否实现了父类或接口要求实现的所有方法等等。
* 字节码校验，这是最复杂的一个阶段，主要是通过数据流和控制流分析，确认程序语义是否合法。如变量赋值和类型转换是否合法，指令跳转是否跳转到方法体以外的字节码上了。但是即使程序通过了字节码校验，也不能保证程序一定是安全的。这涉及到计算机理论的一个悖论，“停机问题”，即不可能通过程序去校验另一个程序是否安全。
* 符号引用校验，这个过程会发生在解析阶段，可见，类加载时，这些阶段可能会交叉进行。这个阶段是校验通过符号引用是否能找到对应的直接引用，符号引用是变量或者方法的名字，直接引用是对应的地址或句柄。

其实验证阶段并非是必须的，比如一份代码，已经在机器上运行了很多次，现在把它部署到其它机器上时，就可以考虑使用-Xverify:none参数来关闭验证，以缩短类加载时间。



## 准备

准备阶段会为类的静态变量分配空间，并赋初始值，一般情况下这个值是类型的零值，如int类型是0，引用类型是null，但也有特例。“private final int x=100”，ConstValue x在准备阶段就会被赋值为100。



## 解析

解析阶段主要是把类中的符号引用替换为直接引用，在解析之前会进行符号引用验证。



## 初始化

初始化阶段会执行类的构造器<clinit>()方法，这个方法是由java编译器自动生成的，并且在子类调用这个方法之前，一定会保证父类已调用。<clinit>()方法会执行代码中的静态语句块，并为静态变量赋值(代码里声明的值)，这个调用过程是顺序进行的。如果多个线程去初始化一个类，JVM保证只会有一个线程去执行这个类的初始化方法，其它线程都会阻塞等待。



# 类加载器

类加载器的作用，是通过全限定名找到对应的class文件，并把它变成二进制字节流载入内存。JVM认为两个类相等，比如这两个类的class文件是同一个，且由同一个类加载器加载。

## 启动类加载器

负责加载`jre\lib`目录，或者被`-Xbootclasspath`参数所指定的路径存放的，能够被虚拟机所识别的类库加载到虚拟机的内存中，这个类加载器的底层是由C++实现的，是虚拟机当中的一部分，其它类加载器都是由Java实现的，独立于虚拟机以外，全部继承自`java.lang.ClassLoader`抽象类。

## 扩展类加载器

## 应用类加载器

## 自定义类加载器

## 双亲委派模型








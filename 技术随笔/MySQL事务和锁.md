[toc]

# 事务

## 简介

数据库的事务是由一组SQL语句组成的逻辑单元，在这组SQL语句中，要么全部执行成功，要么全部执行失败。

## ACID

事务的四大特性，原子性(Atomicity), 一致性(Consistent),隔离性(Isolation),持久性(Durable)。

事务的原子性是指一个事务里的SQL语句要么全部执行成功，要么全部都不执行，不会出现部分SQL语句执行成功的情况。如一个转账事务包括A账户扣款,B账户加钱。不能出现扣款成功但是加钱失败的情况。

事务的一致性是指事务在执行前后状态是一致的，主要可以认为是数据的一致性。比如一次转账不会改变银行里的钱数量。转账的金额不能是一个负数。

事务的隔离性指并发的两个事务应该互补影响。

事务的持久性指一个事务提交后对数据库的影响是永久性的，不应该被数据库宕机等原因影响。

事务的一致性是事务的最终目的，原子性，隔离性和持久性都是保证一致性的手段。

数据库保证原子性和一致性主要是通过undolog和redolog来实现的。这是两种物理日志文件，存储的是数据之前的或被修改的值，相对于binlog这种逻辑日志文件存储修改语句。利用物理日志文件来恢复数据库要比逻辑日志文件快很多。（日志详细的工作流程后面再来补）

## 隔离级别

在MySQL中事务的隔离级别可以分为读未提交，读提交，可重复读和串行化。

读未提交是指一个事务修改数据后即使没有提交事务此时其它事务读到的仍然是修改后的数据，这种隔离级别会产生脏读的问题。

读提交指一个事务修改数据后只有提交了事务，此时其它事务才能读到修改后的数据。这种隔离级别解决了脏读，但是产生了不可重复读的问题。不可重复读是说一个事务在执行过程的两个时间点，读同一份数据但是得到的结果不一致。

可重复读解决了不可重复读问题，在一个事务的生命周期中，任何时间点读到的数据都和事务刚开始时是一致的。这也是MySQL的默认隔离级别。这种隔离级别下会产生幻读问题。幻读指一个事务在执行过程中，由于其它事务插入或删除了行而影响到该事务的执行，比如该事务查询id=1的列不存在，此时其他事务插入一个id=1的行，此时该事务再去插入一个id=1的行就会报主键冲突的错误。

串行化指事务的执行是串行进行的。于是也就不存在幻读问题了。

这四种隔离级别逐渐提高了数据的一致性和准确性，但是并发度却越来越低了。

一般来说，选择哪种隔离级别需要看具体业务场景。 

Innodb数据引擎默认处在可重复读隔离级别，利用MVCC和行锁来解决幻读的问题。

# 锁

## 简介

MySQL的隔离底层都是通过锁来实现的。对于读未提交，数据库不会加锁。对于串行化，读数据加共享锁，写数据加排他锁。加了共享锁的行可以再加共享锁，不能加排他锁。加了排他锁的行不能再加任何其他锁。 读提交和可重复读会兼顾性能，所以不会盲目加锁，底层会通过MVCC方式来实现。

## 悲观锁和乐观锁

其实悲观锁和乐观锁并非是数据库提供的某种具体的锁，而是一种并发控制的思路，我更加愿意把它们称为悲观并发控制和乐观并发控制。

悲观锁顾名思义，总是对外界事务保持保守态度。实际上，串行读隔离级别就是一种悲观并发控制，在读的时候加共享锁，写加排他锁。悲观锁适用于写比较多的场景。对数据的一致性保护的好，但是并发低，同时占用的系统资源也低，因为悲观锁是真的给记录加上了锁，而锁是一种操作系统的资源。

乐观锁是基于版本的控制，它的思路是对于读操作不加锁，对于写操作，先保存之前的记录的版本号，写完以后比较自己之前保存的版本号与数据库里目前记录的版本号，如果不一致则放弃修改。实际上，这种基于版本的控制手段有一个很有名的词语，CAS(compare and swap),这和Java里的自旋锁是同样的思路。乐观锁适用于读操作比较多的业务场景。乐观锁实际上并没有加锁，所以也就没有额外开销。但是在实现上更加复杂，因为必须考虑到业务逻辑失败后等待重试的场景。（原地自旋）

## 行锁和表锁

行锁和表锁只是对锁的粒度的区分，顾名思义，行锁锁住一条记录，表锁锁住整张表。MyISAM数据引擎不支持行锁，Innodb引擎可以支持行锁。

## 间隙锁



## MVCC




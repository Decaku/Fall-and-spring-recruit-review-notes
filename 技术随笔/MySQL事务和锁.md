[toc]

# 事务

## 简介

数据库的事务是由一组SQL语句组成的逻辑单元，在这组SQL语句中，要么全部执行成功，要么全部执行失败。

## ACID

事务的四大特性，原子性(Atomicity), 一致性(Consistent),隔离性(Isolation),持久性(Durable)。

事务的原子性是指一个事务里的SQL语句要么全部执行成功，要么全部都不执行，不会出现部分SQL语句执行成功的情况。如一个转账事务包括A账户扣款,B账户加钱。不能出现扣款成功但是加钱失败的情况。

事务的一致性是指事务在执行前后状态是一致的，主要可以认为是数据的一致性。比如一次转账不会改变银行里的钱数量。转账的金额不能是一个负数。

事务的隔离性指并发的两个事务应该互补影响。

事务的持久性指一个事务提交后对数据库的影响是永久性的，不应该被数据库宕机等原因影响。

事务的一致性是事务的最终目的，原子性，隔离性和持久性都是保证一致性的手段。

数据库保证原子性和一致性主要是通过undolog和redolog来实现的。这是两种物理日志文件，存储的是数据之前的或被修改的值，相对于binlog这种逻辑日志文件存储修改语句。利用物理日志文件来恢复数据库要比逻辑日志文件快很多。（日志详细的工作流程后面再来补）

## 隔离级别

在MySQL中事务的隔离级别可以分为读未提交，读提交，可重复读和串行化。

读未提交是指一个事务修改数据后即使没有提交事务此时其它事务读到的仍然是修改后的数据，这种隔离级别会产生脏读的问题。

读提交指一个事务修改数据后只有提交了事务，此时其它事务才能读到修改后的数据。这种隔离级别解决了脏读，但是产生了不可重复读的问题。不可重复读是说一个事务在执行过程的两个时间点，读同一份数据但是得到的结果不一致。

可重复读解决了不可重复读问题，在一个事务的生命周期中，任何时间点读到的数据都和事务刚开始时是一致的。这也是MySQL的默认隔离级别。这种隔离级别下会产生幻读问题。幻读指一个事务在执行过程中，由于其它事务插入或删除了行而影响到该事务的执行，比如该事务查询id=1的列不存在，此时其他事务插入一个id=1的行，此时该事务再去插入一个id=1的行就会报主键冲突的错误。

串行化指事务的执行是串行进行的。于是也就不存在幻读问题了。

这四种隔离级别逐渐提高了数据的一致性和准确性，但是并发度却越来越低了。

一般来说，选择哪种隔离级别需要看具体业务场景。 

Innodb数据引擎默认处在可重复读隔离级别，利用MVCC和间隙锁来解决幻读的问题。

# 锁

## 简介

MySQL的隔离底层都是通过锁来实现的。对于读未提交，数据库不会加锁。对于串行化，读数据加共享锁，写数据加排他锁。加了共享锁的行可以再加共享锁，不能加排他锁。加了排他锁的行不能再加任何其他锁。 读提交和可重复读会兼顾性能，所以不会盲目加锁，底层会通过MVCC方式来实现。

## 悲观锁和乐观锁

其实悲观锁和乐观锁并非是数据库提供的某种具体的锁，而是一种并发控制的思路，我更加愿意把它们称为悲观并发控制和乐观并发控制。

悲观锁顾名思义，总是对外界事务保持保守态度。实际上，串行读隔离级别就是一种悲观并发控制，在读的时候加共享锁，写加排他锁。悲观锁适用于写比较多的场景。对数据的一致性保护的好，但是并发低，同时占用的系统资源也低，因为悲观锁是真的给记录加上了锁，而锁是一种操作系统的资源。

乐观锁是基于版本的控制，它的思路是对于读操作不加锁，对于写操作，先保存之前的记录的版本号，写完以后比较自己之前保存的版本号与数据库里目前记录的版本号，如果不一致则放弃修改。实际上，这种基于版本的控制手段有一个术语，CAS(compare and swap),这和Java里的自旋锁是同样的思路。乐观锁适用于读操作比较多的业务场景。乐观锁实际上并没有加锁，所以也就没有额外开销。但是在实现上更加复杂，因为必须考虑到业务逻辑失败后等待重试的场景。（原地自旋）

## 行锁和表锁

行锁和表锁只是对锁的粒度的区分，顾名思义，行锁锁住一条记录，表锁锁住整张表。MyISAM数据引擎不支持行锁，Innodb引擎可以支持行锁。

尽管Innodb支持行锁，但有时候也会锁住整张表。举个例子，假设有一张user表，有3个字段，ID，user_id和name，其中user_ud上有索引。在执行SQL “update user set name=“1” where user_id = 100”时会给id=100的行加行锁，但是执行“update user set user_id=50 where name="1" ”时却会锁住整张表，这听起来有些不可思议，但是在存储引擎层因为没有索引的存在是无法快速过滤出满足条件的记录的，于是会锁住整张表然后把记录返回给server层过滤。在实际使用中，server层过滤掉不满足条件的记录然后释放掉锁，最后只保留符合条件的记录的锁，这其实违背了两段锁协议，在两段锁协议中，事务释放锁是在事务提交后。可见即使是MySQL，为了性能也是会违反规范的。

## 解决幻读

在可重复读隔离级别下，通过MVCC可以使得select操作不需要加锁。MVCC全名是Multi Version Concurrency Control，中文名多版本并发控制，它本质上是一种乐观并发控制的手段。MVCC没有固定的实现规范，下面要讨论的是Innodb引擎的实现。

在Innodb中，每行数据会添加两个隐藏字段，一个记录这行数据何时被创建，一个记录这行数据何时过期或被删除。在实际操作中，记录的不是时间，而是事务的版本号。每开启一个新事务，事务的版本号会递增。在select时，只会读取创建版本号<=当前事务版本号，过期版本号>当前事务版本号的数据。这样避免了对select操作进行加锁。

MVCC的这种做法实际上是一种“快照读”，即他读取的其实是历史快照而不是数据库中现在存在的数据。但对于一些对数据时效特别敏感的业务就可能出现问题。例如对于insert/update/delete操作，我们不可能在快照里操作数据，而必须操作数据库，这种操作属于"当前读"(实际上它都不是读了)，为了解决当前读的幻读问题，MySQL事务引入了Next-Key锁。



Next-Key锁是行锁和间隙锁的合并，因为insert操作不是在已经存在的行上操作，而是在已存在的两行的间隙中插入一条新纪录，为了防止数据新增，MySQL会把两行的间隙上锁。因为间隙锁总会在插入记录的前后区间上锁，所以许多没有必要的区间可能也会加锁。同时，如果要上锁的字段上没有索引，那么整张表都会加上Gap锁，并且无法像行锁一样在Server层自动解除不满足条件的锁。（间隙锁这里好像比较抽象，有空来补张图。。。）


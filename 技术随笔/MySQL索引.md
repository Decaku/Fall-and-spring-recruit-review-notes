
* 这篇文章不写目录了


&emsp;&emsp;索引本质上是一种数据结构，而数据结构的作用在于帮助快速查找，插入，更新和删除数据。

&emsp;&emsp;MySQL数据库中的Memory引擎使用的是哈希索引，但是哈希表不支持范围查询和排序，另外如果数据建立索引的列出现大量重复会导致大规模哈希碰撞，显然也不合适。所以在Innodb和MyISAM引擎中，索引使用的数据结构是B+ tree。在MyISAM引擎里，索引文件和数据文件是分开的，根据索引查询的是实际数据所在的地址，这样就会多一次IO。而Innodb引擎数据文件和索引文件是一个文件。

&emsp;&emsp;AVL tree没有办法成为索引的数据结构的原因是AVL tree总是要求严格平衡（每个结点的左右子树高度差不能超过1），所以在遇到插入和删除这种破坏树的形态的操作时，需要经过多次旋转操作来保证严格平衡。 Red-Black tree在AVL tree上做出了优化，它放弃严格平衡来使每次树形态变化后的调整操作到达常数次，但它也不适合做索引，原因是Red-Black tree每个结点只能存储一个key,并且它是二叉树，这意味着树可能会非常高。而每沿着树边走一次，都会是一次磁盘IO。

&emsp;&emsp;为什么在索引树上每往下走一层，都会多一次IO呢？这是因为一开始所有的数据都保存在硬盘上，每次往下多走一层时，都需要把数据从硬盘调到内存里，这就是一次IO。IO时，会从硬盘取出一块(页)的数据加载到内存里。通过 show variables like "%innodb_page_size%"; 这条语句可以查询一块的大小（一般是16KB）。而B+ tree的每一个结点，实际都是一块。每次读写一块，充分利用了计算机局部性原理，提高效率。

&emsp;&emsp;B+ tree从形态上看起来非常矮胖，对于千万量级的数据，最后B+ tree索引树的高度也就3、4层而已，所以IO次数比较少。 另外B tree和B+ tree类似,也是多叉平衡树。B tree 和B+ tree最大的区别在于B tree的每个结点都会保存数据，而B + tree只有叶子结点会储存数据，非叶结点只储存key值。因为这个特性，B + tree的非叶结点所能存储的key的个数会比B tree多很多（每个结点大小相同而B+ tree不存key对应的数据），所以，相同高度的B+ tree所能表示的数据范围会比B tree多很多。 

&emsp;&emsp;B+ tree叶子结点的数据从左到右是有序的，使用双向链表串联起来，在做全表扫描的时候非常方便。

&emsp;&emsp;聊完索引的数据结构，再来聊一下索引的种类。可以简单把索引分为聚集索引和非聚集索引两种。在Innodb引擎中，聚集索引就等价于主键索引。Innodb数据引擎一定会为table生成主键，如果没有显示指定主键，则数据库会选择不存在重复值的字段作为主键，如果不存在这样的字段，则会生成一个6字节的row_id作为主键。聚集索引和非聚集索引的关系，引用一个广为流传的例子来描述。使用聚集索引查询数据好比使用拼音检索法从字典里查汉字，使用非聚集索引查询数据好比使用部首法查字典。而字典里存储汉字的顺序就是按照拼音序，部首笔画相邻的两个汉字在字典里不一定相邻。所以我们可以得出结论，聚集索引的逻辑顺序和table的物理存储顺序是一致的，而非聚集索引的逻辑顺序和table的物理存储顺序不一定相同，这也是为什么一张table里只允许有一个聚集索引的原因。

&emsp;&emsp;聚集索引的叶子结点存储的就是一条完整的记录，而非聚集索引的叶子结点存储的是主键值和该列值。如果所有的索引都存储整条数据的话，所消耗的空间就太大了。使用非聚集索引查询时，经常会需要回表查询，也就是第一次先查出主键，然后回到聚集索引中通过主键查询整条记录。

&emsp;&emsp;如果想要避免回表查询导致性能降低，就需要实现索引覆盖。索引覆盖实际就是通过建立联合索引，使得联合索引覆盖到所有查询的字段，从而避免回表查询。联合索引的本质是B+ tree的每个结点的key是一个多元组而不是单一字段，建立索引的过程和普通索引一样。联合索引有最左匹配原则。

[![DB5481.md.png](https://s3.ax1x.com/2020/11/27/DB5481.md.png)](https://imgchr.com/i/DB5481)

&emsp;&emsp;上图是在两个列(a,b)上建立索引的B+ tree的例子。因为是二元组，所以总是先按照a排序，在a相同的情况下再按b排序，所以对于查询"select * from table where a=?"和"select * from table where a=? and b=?"可以命中索引，而对于查询"select * from table where b=?" 无法命中索引。我们也可以简单认为数据库在(a)和(a,b)上分别建立了索引，实际是只有一棵B+ tree。

&emsp;&emsp;关于其它的索引分类方式，这里不再赘述了。

&emsp;&emsp;索引下推。index condition pushdown，简称ICP，是在MySQL5.6以后的版本推出的。举个例子，假设在(name,age)上建立了联合索引，对于查询"select * from user where name like "王%" and age=20"如果没有索引下推优化，则会在数据库引擎查询时只限制name条件，然后把查出来的结果交给server层。在加上索引下推优化以后，则第一次查询在引擎层就会对name和age两个条件进行限制。 加上索引下推优化后回表次数会减少。因为我们的查询流程是先在非聚集索引上查出主键id交付给server层，server层再向引擎传递查询命令去聚集索引查询整条记录。由于交付给server层的数据集结果少了，所以减少了回表的次数。

&emsp;&emsp;适合建立索引的列，包括经常需要查询的列，经常需要排序和范围查询的列。在结果集取值很少的列上不适合建立索引，比如性别，因为通过索引过滤出的结果集最后还是会很大。索引是需要占据空间的，并且在插入和删除数据的时候还需要额外维护B+ tree，所以需要合理地建立索引。

&emsp;&emsp;索引失效。有几种情况，实际就是考虑哪些查询条件不能通过二叉查找树加速。比如以like开头的%模糊查找。

&emsp;&emsp;通常会使用一个自增的id作为数据库主键。name这类string类型的列不适合做主键（在假设不存在重复的情况下）。使用自增id做主键，插入数据时只需要在页的最后增加一条新的记录即可，如果页已经满了，新建数据页然后增加一条记录。而如果使用name做主键，需要先查询定位到这条记录应该所在的页，该数据页可能还不在内存里，需要从硬盘调入内存，这实际上增加了随机IO的次数。同时，把一条记录插入一个已经满了的数据页，需要对原来的页进行分裂，耗时耗力。
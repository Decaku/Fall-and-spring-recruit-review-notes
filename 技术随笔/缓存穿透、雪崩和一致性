[toc]

# 缓存穿透、雪崩和一致性



## 缓存穿透

缓存的目的是为了缓解数据库的压力，但如果同一时间大量的请求绕过缓存而落到数据库上，就有可能打垮数据库，这样的情况称为缓存穿透。通常如果攻击者在短时间内伪造大量不存在的key,就会导致请求绕过缓存落库。

解决办法有两种，一种是每当请求到并不存在的key时，去数据库里查询后也把这条数据加到缓存里，并把value设置成null。这样的数据应该设置较短的过期时间。

事实上，上面一种办法只能减少被攻击的风险，如果能构造出许多不存在且不重复的key,仍然没有办法避免被攻击。于是，考虑第二种办法bloom filter。它的作用和集合是一样的，考虑在内存里维护一个set，set里存放所有的key，每次当请求过来时，先检查set里是否有这个key，没有就拒绝服务。但是因为数据量的原因，如果简单维护一个key，内存可能存不下。因为我们本质上是要检查一个key是否存在，所以考虑使用bitset和hash来实现。bitset是一个二进制数组，它的每一位只有0/1两种取值，因此每一个成员只占1bit的空间。我们采用多种hash函数，根据一个key计算得到多个值，然后把bitset里对应下标的地方都改成1。这样，判断一个key是否存在，等价于检查这几个位置是否都是1。bloom filter的问题很明显。首先它很难撤销已经加入的key，因为一个桶可能被多个key所映射了（除非再去维护一下这个桶被映射的次数，但这样就和我们压缩空间的初衷相悖离了。。。）。另外，由于hash的原因，即使计算出的桶里的值都是1，也无法保证这个key就一定存在，要减少这种碰撞需要选择恰当的hash函数，以及hash空间的大小。

```
https://github.com/lujinda/simplebloom   一个使用go实现的bloom filter
```



## 缓存雪崩

缓存雪崩，有些资料里把它叫成缓存击穿。是由于同一时间大量key过期，导致查询落库。这个解决思路比较简单。给key的过期时间设置随机值，并把热点key设置成永不过期。但这样的做法只能降低缓存雪崩的风险。一种更加稳妥的做法是，利用redis的setnx命令实现分布式锁，每次保证只有一个线程访问数据库，其它线程没有取得锁就直接返回缓存内容。但是这样增加了数据不一致的风险。。。所以实际上还是没有一个完美的解决思路。



## 缓存一致性

缓存一致性主要是由于数据库和缓存双写而导致的。读数据的时候我们会先去缓存读，如果缓存没有，则会去数据库读，然后把数据写到缓存。而修改数据操作，会采取写数据库，删缓存的做法，并不会选择修改缓存里的值。因为修改缓存会产生更复杂的并发问题。但是无论先写库还是先删缓存，都没有办法保证数据一致性。

先写库，如果后续删缓存失败则数据不一致。先删缓存，此时如果另一个线程来读数据发现缓存里没有，于是它就去库里读并把数据拷贝到缓存里了，此时由于网络阻塞等原因，删缓存的线程这才去改库，于是也产生了数据不一致的问题。

两种解决思路。延时双删，先删除缓存，然后改库，这之后redis休眠一段时间再删除一次缓存，两次删除降低了数据不一致的风险，但实际上是不能保证强一致性的，比如因为网络原因，第二个线程读到数据库里的值后等待了一段时间，直到第一个线程第二次删缓存以后它又改了缓存。另外，这种策略每次修改缓存要让redis休眠一段时间，会对性能造成影响。

第二种思路是基于订阅binlog的同步机制。(好像还不太了解，等我看懂了再来补。。。)


# Nagle算法

Nagle算法适用于低速网络上进行数据传输。

在一些场景中可能会大量传递一些小报文(telnet协议)，而tcp协议的头部就有40个byte，如果网络里大量传递的都是1byte的数据包，网络的利用率不高。于是Nagle算法规定了在任何一个时刻，一个tcp连接中最多只允许存在一个未被确认的小段，所谓的小段，就是没有达到MSS(最大分段大小)的包。 如果tcp连接中存在了一个未被确认的小段，那么发送端会讲之后的小段缓冲累积，直到收到之前的小端ACK或者达到MSS。

分析算法，发现如果接收端的ACK确认得很快，那么Nagle算法其实没啥用，因为还是会一直发送小段而不会累积。事实上，ACK确认一般都是有延迟的(linux 40ms)，这样的好处是如果我正好要发送数据到对端，那么就可以把ACK携带在这次的报文里而不用重新再发送一个额外报文，同时在等待的这段时间里可能会收到多个报文，tcp协议允许一个ACK确认多个报文。

由于ack延迟的存在，Nagle算法可能会导致数据传输不及时，因为如果有小段没有确认，发送端就不能传输数据。

另外，Nagle还会导致粘包。



# MTU和MSS

http://wulc.me/2015/12/08/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%B8%AD%E7%9A%84MTU%E4%B8%8EMSS/

偷个懒看这个吧



# 流量控制和拥塞控制

流量控制是防止发送端发送速率过快时，接收端来不及读取缓冲区里的数据，从而使缓冲溢出，数据丢失。

拥塞控制是防止发送端发送速率过快，超过了网络负载，造成路由器丢包。

简单来说，流量控制是减少接收端的压力，而拥塞控制是减少网络压力。其实流量控制和拥塞控制都是用来决定发送窗口的大小。

## 流量控制

流量控制是通过滑动窗口来实现。

swnd=min(rwnd, cwnd)，即发送窗口大小等于接收端口大小和拥塞窗口大小中的较小值。

假设不考虑网络拥塞，那么swnd=rwnd，接收端通过传递给对端ack和窗口大小，发送端就可以知道将要发送的数据范围(ack到ack+swnd)。

根据tcp协议，接收端可以累积确认。同时乱序到达的包可以先放在缓冲区中(这点toc协议里没规定)

还得有一些机制避免流量控制时出现死锁。一个场景，当接收端发送0窗口后发送端将停止发送数据，但未来某个时间点后接收端可以再接收数据了，于是发送了一个接收窗口不为0的报文给对端，如果这个报文丢失，双方就进入死锁了。tcp提供了一种机制，当发送端收到0窗口应答后会启动一个定时器，时间到了就去主动询问对端的接收窗口，如果仍然返回0窗口，就重置定时器继续等待。

## 拥塞控制

从丢包情况来推测网络负载情况，防止过多数据注入网络。

主要通过三个算法，慢启动，快重传，快恢复。

### 慢启动

所谓慢，其实指的是刚开始发送到网络里的分组数量不能过多。刚开始发送数据时cwnd的大小为一个MSS，以后每次收到一个ack，都把cwnd的大小乘2，以指数速度增长。当cwnd的大小达到阈值后开始执行拥塞避免算法，即以后每次收到ack后cwnd大小都+1而不是翻倍。当判断网络中出现拥塞，如没有按时收到ack，就把cwnd的阈值大小变成一半，并重置cwnd大小为1，重新执行慢启动算法。

### 快重传

快重传规定当接收端收到一个乱序到达的报文时就立即返回ack。(正常情况ack是延迟确认的，上文讲Nagle算法时提过) 

发送端在收到连续三个相同的ack后就立即重传丢失的报文。

### 快恢复

发送端收到连续三个ack后就把慢启动的阈值减半。但是不会把cwnd置为1，因为考虑到如果网络拥塞就不会连续收到3个ack，所以会把cwnd减半，然后执行拥塞避免算法，使cwnd线性增加。




[toc]



主要讨论Linux下的各种锁，这些锁都是OS/Posix提供的组件/API，其他锁的概念，比如数据库/Java包里的锁都是基于操作系统的API封装了一套新的逻辑。

这块感觉除了理解概念意外，最好动手编程实现一下。

# 信号量(semaphore)

信号量可以限制访问临界区的最大线程数量，临界区可以是代码段或某种资源。企图进入临界区的线程会先执行P操作，信号量会减1，如果信号量变成负数则操作系统会拒绝线程进入临界区。当线程退出临界区会执行V操作，信号量加1。PV是原语操作，不可中断。

V操作有可能不是由进入临界区的线程执行的，而是由另一个称为生产者的线程来执行，这就是生产者-消费者模型。

```
与Mutex的区别？

Mutex是互斥锁，即同一时间只能有一个线程持有，所以最大为1的semaphore的就是mutex，而mutex加计数器可以实现semaphore。
```

```
自己实现信号量？

// waiting...
```



# 自旋锁(spinlock)

自旋锁的特点是当临界区被加锁时，竞争它的线程不会阻塞睡眠，而是会原地轮询，等待锁释放。自旋锁适用于执行快，代码少的临界区。可以避免上下文切换和操作系统唤醒线程。但是一直原地自旋很消耗cpu资源。



# 互斥锁(mutex)

互斥锁只能由加锁的线程释放，并且竞争锁的线程会进入阻塞睡眠，由操作系统唤醒。mutex可能会出现假唤醒。

如果一个线程能重复加锁，则称为可重入锁，也称为可递归锁，否则是非重入/非递归锁。reentrant-lock / non-reentrant-lock，

可重入锁的优点可以避免线程重复加锁时出现死锁。

```
据说可重入锁这个名字是从java里拿来的，原来就叫可递归互斥量
```



# 读写锁(rwlock)

在某些场景下，如果暴力使用互斥锁来保护临界区，效率不好。

读写锁分为读锁和写锁，临界区被加了读锁以后可以继续加读锁，但不能加写锁，临界区被加了写锁以后不能再加任何锁。

适用于读操作多的场景。但是可能会出现写饥饿。

```
实现一个写优先的读写锁？或者说避免写饿死。
读锁和写锁加锁时同时使用try lock，并且优先满足写锁。
```

C++11没有引入读写锁，但是在C++17中出现的**std::shared_mutex**可以模拟读写锁



# 条件变量(condition variables)

通常配合互斥锁一起使用。竞争互斥锁失败的线程会阻塞休眠，但是在某些业务场景中无法通过系统来唤醒，条件变量允许线程阻塞时另一个线程发送信号来实现线程解除阻塞。

```
先进行条件通知还是先解除互斥锁呢？
一般来说，先解除互斥锁，然后进行条件通知，这是为了避免唤醒太多线程，造成过多的上下文切换。
```

经典应用：生产者-消费者模型





暂时总结到这

顺序锁。。。

RCU锁。。。









